//! RPC payload-attribute structures used by Taiko engine and builder flows.
use alloy_primitives::{Address, B256, Bytes as AlloyBytes, U256};
use alloy_rpc_types_engine::PayloadAttributes as EthPayloadAttributes;
#[cfg(feature = "net")]
use alloy_rpc_types_eth::Withdrawal;
#[cfg(feature = "net")]
use reth_chainspec::{EthChainSpec, EthereumHardforks};
#[cfg(feature = "net")]
use reth_engine_local::LocalPayloadAttributesBuilder;
#[cfg(feature = "net")]
use reth_node_api::{PayloadAttributes, PayloadAttributesBuilder};
#[cfg(feature = "net")]
use reth_primitives_traits::SealedHeader;
#[cfg(feature = "serde")]
use serde_with::{As, Bytes, base64::Base64};

/// Taiko Payload Attributes
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "serde", serde(rename_all = "camelCase"))]
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct TaikoPayloadAttributes {
    /// The ETH payload attributes
    #[cfg_attr(feature = "serde", serde(flatten))]
    pub payload_attributes: EthPayloadAttributes,
    /// Base fee per gas for the L2 block.
    pub base_fee_per_gas: U256,
    /// The metadata for the L2 block.
    pub block_metadata: TaikoBlockMetadata,
    /// The L1 origin information for the L2 block.
    pub l1_origin: RpcL1Origin,
    /// Prebuilt anchor transaction (RLP-encoded signed transaction).
    ///
    /// When provided, the payload builder uses this transaction
    /// instead of building an anchor transaction from checkpoint parameters.
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub anchor_transaction: Option<AlloyBytes>,
}

#[cfg(feature = "net")]
impl PayloadAttributes for TaikoPayloadAttributes {
    /// Returns the timestamp to be used in the payload job.
    fn timestamp(&self) -> u64 {
        self.payload_attributes.timestamp()
    }

    /// Returns the withdrawals for the given payload attributes.
    fn withdrawals(&self) -> Option<&Vec<Withdrawal>> {
        self.payload_attributes.withdrawals()
    }

    /// Return the parent beacon block root for the payload attributes.
    fn parent_beacon_block_root(&self) -> Option<B256> {
        self.payload_attributes.parent_beacon_block_root()
    }
}

/// The metadata for a Taiko block, which is generated by the Taiko protocol.
#[derive(Clone, Debug, Default, PartialEq, Eq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "serde", serde(rename_all = "camelCase"))]
pub struct TaikoBlockMetadata {
    /// The suggested fee recipient address for the L2 block.
    pub beneficiary: Address,
    /// The gas limit for the L2 block.
    pub gas_limit: u64,
    /// The timestamp for the L2 block.
    pub timestamp: U256,
    /// The mix hash for the L2 block.
    pub mix_hash: B256,
    /// The RLP-encoded transaction list for the L2 block.
    ///
    /// - `None`: Transactions should be selected from the mempool.
    /// - `Some(bytes)`: Use the provided transaction list (legacy mode).
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub tx_list: Option<AlloyBytes>,
    /// The extra data for the L2 block.
    #[cfg_attr(feature = "serde", serde(with = "As::<Base64>"))]
    pub extra_data: AlloyBytes,
}

/// The L1 origin information for a Taiko block, which includes the information about the L1 block
/// that including the given L2 block.
#[derive(Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "serde", serde(rename_all = "camelCase"))]
pub struct RpcL1Origin {
    /// The number of the L2 block.
    #[cfg_attr(feature = "serde", serde(rename = "blockID"))]
    pub block_id: U256,
    /// The hash of the L2 block.
    pub l2_block_hash: B256,
    /// The height of the L1 block that included the L2 block.
    pub l1_block_height: Option<U256>,
    /// The hash of the L1 block that included the L2 block.
    pub l1_block_hash: Option<B256>,
    /// The ID of the build payload arguments.
    #[cfg_attr(feature = "serde", serde(rename = "buildPayloadArgsID"))]
    pub build_payload_args_id: [u8; 8],
    /// Indicates if the L2 block was included as a forced inclusion.
    pub is_forced_inclusion: bool,
    /// The signature of the L2 block payload.
    #[cfg_attr(feature = "serde", serde(with = "As::<Bytes>"))]
    pub signature: [u8; 65],
}

impl RpcL1Origin {
    /// Checks if the L1 origin's L2 block is a preconfirmation block.
    pub fn is_preconf_block(&self) -> bool {
        self.l1_block_height.is_none() || self.l1_block_height == Some(U256::ZERO)
    }
}

/// Implement `PayloadAttributesBuilder` for `LocalPayloadAttributesBuilder<TaikoChainSpec>`,
/// to build `TaikoPayloadAttributes` from the local payload attributes builder.
#[cfg(any(feature = "net", feature = "local-payload-builder"))]
impl<C> PayloadAttributesBuilder<TaikoPayloadAttributes, C::Header>
    for LocalPayloadAttributesBuilder<C>
where
    C: EthChainSpec + EthereumHardforks + 'static,
{
    /// Return a new payload attribute from the builder.
    fn build(&self, parent: &SealedHeader<C::Header>) -> TaikoPayloadAttributes {
        // Delegate to the underlying ETH payload builder to avoid self-recursion.

        use alloy_primitives::Address;
        let eth_payload_attributes = <Self as PayloadAttributesBuilder<
            EthPayloadAttributes,
            C::Header,
        >>::build(self, parent);
        let timestamp = eth_payload_attributes.timestamp;

        TaikoPayloadAttributes {
            payload_attributes: eth_payload_attributes,
            base_fee_per_gas: U256::ZERO,
            block_metadata: TaikoBlockMetadata {
                beneficiary: Address::random(),
                timestamp: U256::from(timestamp),
                gas_limit: reth_primitives_traits::constants::MAXIMUM_GAS_LIMIT_BLOCK,
                mix_hash: B256::random(),
                tx_list: Some(AlloyBytes::new()),
                extra_data: AlloyBytes::new(),
            },
            l1_origin: RpcL1Origin {
                block_id: U256::ZERO,
                l2_block_hash: B256::ZERO,
                l1_block_hash: None,
                l1_block_height: None,
                build_payload_args_id: [0; 8],
                is_forced_inclusion: false,
                signature: [0; 65],
            },
            anchor_transaction: None,
        }
    }
}

#[cfg(feature = "net")]
#[cfg(test)]
#[cfg(feature = "local-payload-builder")]
mod tests {
    use super::*;
    use alloy_consensus::Header;
    use reth_chainspec::ChainSpec;
    use reth_engine_local::LocalPayloadAttributesBuilder;
    use reth_payload_primitives::PayloadAttributesBuilder;
    use reth_primitives_traits::constants::MAXIMUM_GAS_LIMIT_BLOCK;
    use std::sync::Arc;

    #[test]
    fn build_is_deterministic_and_delegates() {
        let builder = LocalPayloadAttributesBuilder::new(Arc::new(ChainSpec::<Header>::default()));
        // Build a sealed header to pass to the builder
        let parent_header = Header::default();
        let parent = SealedHeader::seal_slow(parent_header);

        let first: TaikoPayloadAttributes = builder.build(&parent);
        let second: TaikoPayloadAttributes = builder.build(&parent);

        // Stable Taiko defaults that should not depend on randomness.
        assert_eq!(first.block_metadata.gas_limit, MAXIMUM_GAS_LIMIT_BLOCK);
        assert_eq!(second.block_metadata.gas_limit, MAXIMUM_GAS_LIMIT_BLOCK);
        assert_eq!(first.block_metadata.tx_list, Some(AlloyBytes::new()));
        assert_eq!(second.block_metadata.tx_list, Some(AlloyBytes::new()));

        // L1 origin defaults remain zeroed and stable.
        assert_eq!(first.l1_origin.block_id, U256::ZERO);
        assert_eq!(first.l1_origin, second.l1_origin);
    }
}
